# Learning Log — 2025-11-05

## Unified Editor Architecture: Tab-Based Interface

**Context:** Needed to consolidate 9 separate editor HTML files into a single maintainable interface.

**Lesson:** When you have multiple similar pages/views, a tabbed interface with shared infrastructure is more maintainable than separate files. Key benefits:

1. **Single Source of Truth**: One HTML file, one CSS file, one navigation pattern
2. **Consistent Behavior**: All tabs share the same layout, styling, and interaction patterns
3. **Easier Updates**: Changes to shared elements (like forms) apply to all tabs automatically
4. **Reduced Code Duplication**: CSS variables, utility classes, and shared JS functions benefit all tabs

**Implementation Pattern:**

```javascript
// Tab controller with hash-based deep linking
var TAB_CONFIG = {
  'wonders': { name: 'World Wonders', module: 'data-wonders' },
  'leaders': { name: 'Leaders', module: 'data-leaders' },
  // ... etc
};

function switchTab(tabId) {
  // Hide all tabs
  document.querySelectorAll('.tab-content').forEach(function(tab) {
    tab.classList.remove('active');
  });
  
  // Show selected tab
  var selectedTab = document.getElementById('tab-content-' + tabId);
  if (selectedTab) {
    selectedTab.classList.add('active');
    // Initialize module if needed
    initializeModule(TAB_CONFIG[tabId].module);
  }
}
```

**Why This Matters:** This pattern applies to any application with multiple similar views. The investment in a unified architecture pays off quickly as you add more entity types or need to make global changes.

---

## ID Uniqueness in Unified HTML

**Context:** After consolidating multiple editor pages into one HTML file, many buttons stopped working due to duplicate IDs.

**Lesson:** HTML IDs must be unique within a single document. When merging multiple similar pages, you must prefix IDs with a namespace to ensure uniqueness.

**Solution Pattern:**

```html
<!-- Before (duplicate IDs across tabs) -->
<button id="add-effect-button">+ Add Effect</button>  <!-- In wonders tab -->
<button id="add-effect-button">+ Add Effect</button>  <!-- In leaders tab - DUPLICATE! -->

<!-- After (unique IDs with namespace prefix) -->
<button id="wonders-add-effect-button">+ Add Effect</button>
<button id="leaders-add-effect-button">+ Add Effect</button>
```

**JavaScript Updates:**

```javascript
// Before
var addEffectButton = document.getElementById('add-effect-button');

// After
var addEffectButton = document.getElementById('wonders-add-effect-button');
```

**Why This Matters:** While duplicate IDs might not cause immediate runtime errors (if only one tab is visible), they create invalid HTML and can cause subtle bugs. Always ensure IDs are unique, especially when consolidating similar pages.

---

## HTML Validation: Accessibility & Standards Compliance

**Context:** CI checks failed with 45 HTML validation errors after consolidating editors.

**Lesson:** HTML validators catch real accessibility and standards issues. Common problems:

1. **Raw `&` characters**: Must be encoded as `&amp;` in HTML content
2. **Missing `scope` attributes**: Table headers need `scope="col"` or `scope="row"` for screen readers
3. **Missing `aria-label`**: Landmark elements (like `<section>`) need accessible names
4. **Inline styles**: Should be moved to CSS classes for maintainability

**Fixes Applied:**

```html
<!-- Raw & character -->
<h3>Production & Associated Civilization</h3>  <!-- ❌ Invalid -->
<h3>Production &amp; Associated Civilization</h3>  <!-- ✅ Valid -->

<!-- Missing scope -->
<th>Name</th>  <!-- ❌ Missing scope -->
<th scope="col">Name</th>  <!-- ✅ Valid -->

<!-- Missing aria-label -->
<section class="panel data-tools">  <!-- ❌ No accessible name -->
<section class="panel data-tools" aria-label="Data tools for World Wonders">  <!-- ✅ Valid -->

<!-- Inline styles -->
<p style="color:#52606d; font-size:0.9rem;">Text</p>  <!-- ❌ Inline -->
<p class="text-muted">Text</p>  <!-- ✅ CSS class -->
```

**Why This Matters:** Valid HTML improves accessibility, makes the code more maintainable, and ensures consistent rendering across browsers. Utility CSS classes make it easy to apply consistent styling without inline styles.

---

## CSS Utility Classes vs Inline Styles

**Context:** Removed 15+ inline styles from HTML files to fix validation errors and improve maintainability.

**Lesson:** Utility CSS classes are superior to inline styles for:

1. **Maintainability**: Change styling in one place (CSS file) instead of multiple HTML locations
2. **Consistency**: Ensures all similar elements use the same styling
3. **Performance**: CSS classes are cached and reused, inline styles are parsed per element
4. **Validation**: HTML validators flag inline styles as warnings/errors
5. **Theming**: CSS variables make it easy to change colors/spacing globally

**Pattern:**

```css
/* Utility classes in CSS */
.text-muted {
  color: var(--color-text-muted);
  font-size: var(--font-size-sm);
}

.text-center {
  text-align: center;
}

.mt-lg {
  margin-top: var(--spacing-lg);
}

.hidden {
  display: none;
}
```

**HTML Usage:**

```html
<!-- Before -->
<p style="color:#52606d; font-size:0.9rem;">Text</p>
<button style="display:none;">Cancel</button>

<!-- After -->
<p class="text-muted">Text</p>
<button class="hidden">Cancel</button>
```

**Why This Matters:** This pattern scales better as projects grow. Utility classes become a shared vocabulary that developers can use consistently. CSS variables make global changes (like color scheme updates) trivial.

---

## JavaScript: classList vs style.display

**Context:** Updated JavaScript to use `classList.add/remove()` instead of directly setting `style.display`.

**Lesson:** Using CSS classes for dynamic state is better than manipulating inline styles:

1. **Separation of Concerns**: Styling belongs in CSS, not JavaScript
2. **Consistency**: Same classes can be used in HTML for initial state
3. **Maintainability**: Change styling in CSS, not scattered across JS files
4. **Validation**: Avoids HTML validation warnings about inline styles

**Pattern:**

```javascript
// Before
cancelEditButton.style.display = 'none';
cancelEditButton.style.display = 'inline-block';

// After
cancelEditButton.classList.add('hidden');
cancelEditButton.classList.remove('hidden');
```

**CSS:**

```css
.hidden {
  display: none;
}
```

**Why This Matters:** This creates a cleaner separation between structure (HTML), presentation (CSS), and behavior (JavaScript). It also makes it easier to change how elements are hidden (e.g., `visibility: hidden` vs `display: none`) without touching JavaScript.

---

## Repository Cleanup: Removing Unrelated Files

**Context:** Discovered `pihole/` folder with 7 files unrelated to the Civ7 project.

**Lesson:** It's important to periodically audit the repository for files that don't belong to the project. This can happen when:

1. Working with multiple agents that might create files in the wrong project
2. Copy-pasting code from other projects
3. Experimenting with features that aren't part of the main project

**Best Practices:**

1. **Regular audits**: Review file structure periodically
2. **Clear project scope**: Keep a README or project description that defines what belongs
3. **Gitignore**: Use `.gitignore` to prevent accidentally committing unrelated files
4. **Clean commits**: Remove unrelated files in a separate commit for clarity

**Why This Matters:** Unrelated files create confusion, increase repository size, and can cause issues during deployment. Keeping the repository focused on the project scope makes it easier to understand and maintain.

---

## CSS Variables for Theme Consistency

**Context:** Extracted shared CSS into `css/editors.css` with CSS variables for colors, spacing, and other design tokens.

**Lesson:** CSS variables (custom properties) make theming and consistency much easier:

1. **Single Source of Truth**: Define colors/spacing once, use everywhere
2. **Easy Theming**: Change variables to create different themes
3. **Consistency**: Harder to accidentally use wrong colors/spacing
4. **Maintainability**: Update design tokens in one place

**Pattern:**

```css
:root {
  --color-primary: #0077cc;
  --color-text-muted: #52606d;
  --spacing-lg: 16px;
  --font-size-sm: 0.9rem;
}

.text-muted {
  color: var(--color-text-muted);
  font-size: var(--font-size-sm);
}

button.primary {
  background: var(--color-primary);
}
```

**Why This Matters:** This is standard practice in modern CSS. It makes the design system explicit and easy to modify. If you need to change the primary color across the entire application, you update one variable instead of searching through hundreds of CSS rules.

---

## Git: Handling Staged vs Unstaged Changes

**Context:** Had changes staged (unified editor) but needed to make additional fixes (HTML validation) before committing.

**Lesson:** Git's staging area allows you to make incremental commits. When you discover issues after staging:

1. **Fix the issues** in your working directory
2. **Stage the fixes** with `git add` for the specific files
3. **Review with `git status`** to see what's staged vs unstaged
4. **Commit incrementally** - separate commits for separate concerns (e.g., feature commit + validation fix commit)

**Workflow:**

```bash
# Initial work
git add data-editor.html css/editors.css
git status  # See what's staged

# Discover issues, fix them
# ... make fixes ...

# Stage fixes separately
git add data-editor.html  # Or specific files
git commit -m "fix: resolve HTML validation errors"

# Or stage everything together
git add -A
git commit -m "feat: unified editor + validation fixes"
```

**Why This Matters:** Clear commit history makes it easier to understand what changed and why. Separate commits for features and bug fixes make it easier to revert specific changes if needed.
