# Learning Log — 2025-11-03

## Database Check Constraints: Null vs Empty String

**Context:** Encountered `23514` error when saving World Wonders with empty owner type.

**Lesson:** PostgreSQL check constraints like `CHECK (field IN ('A', 'B', 'C'))` do **not** accept empty strings — they only accept the specified values or `NULL`. When a field is optional, you must explicitly send `null`, not `''`.

**Solution:** Changed `convertToDb` in `store-supabase.js`:

```javascript
// Before
last_owner_role: wonder.ownerType || '',

// After
last_owner_role: (wonder.ownerType && wonder.ownerType.trim()) ? wonder.ownerType : null,
```

**Why This Matters:** This pattern will apply to all enum-like fields in the database. Better to catch this early than debug it repeatedly across different editors.

---

## Async/Promise Handling in Vanilla JavaScript

**Context:** Initial save operations were failing silently because `data-wonders.js` was calling async store methods synchronously.

**Lesson:** When migrating from synchronous localStorage to async Supabase, every data access must be updated to handle Promises. This means:

1. Use `.then()` and `.catch()` for Promise handling
2. Chain dependent operations inside `.then()` callbacks
3. Add error logging in `.catch()` blocks
4. Update UI state after async operations complete

**Example Pattern:**

```javascript
// Before (localStorage - synchronous)
var wonders = store.getWorldWonders();
renderTable(wonders);

// After (Supabase - asynchronous)
store.getWorldWondersAsync().then(function(wonders) {
  renderTable(wonders);
}).catch(function(err) {
  console.error('Load failed:', err);
  showStatus('Failed to load wonders', 'error');
});
```

**Why This Matters:** Every data editor will need this pattern. Consider creating helper utilities to reduce boilerplate.

---

## Autocomplete Dropdown Positioning

**Context:** Autocomplete dropdowns were appearing off-screen (e.g., `top: '1128px'` on a form that starts at `y: 200`).

**Lesson:** When positioning absolutely-placed dropdowns inside a scrollable container, calculate position **relative to the container**, not the document.

**Solution:**

```javascript
function positionDropdown(dropdown, input) {
  var inputRect = input.getBoundingClientRect();
  var container = dropdown.parentElement;
  var containerRect = container.getBoundingClientRect();
  
  // Position relative to container, not document
  var top = (inputRect.bottom - containerRect.top + container.scrollTop) + 'px';
  var left = (inputRect.left - containerRect.left) + 'px';
  var width = inputRect.width + 'px';
  
  dropdown.style.top = top;
  dropdown.style.left = left;
  dropdown.style.width = width;
}
```

**Why This Matters:** This pattern applies to any overlay component (tooltips, modals, popovers). Document-relative positioning only works for fixed-position overlays at the root level.

---

## Dynamic Form Fields for JSON Data

**Context:** Needed human-friendly editing for arrays (effects) and nested objects (civ-specific unlock) without manual JSON editing.

**Lesson:** For array data, create a "builder" pattern with:

1. Container div for dynamic inputs
2. "Add" button to append new input fields
3. "Remove" button on each field
4. Collection function that gathers all values into an array

**Example:**

```javascript
function addEffectInput(value) {
  var wrapper = document.createElement('div');
  var input = document.createElement('input');
  input.type = 'text';
  input.value = value || '';
  
  var removeBtn = document.createElement('button');
  removeBtn.textContent = '✕';
  removeBtn.onclick = function() { wrapper.remove(); };
  
  wrapper.appendChild(input);
  wrapper.appendChild(removeBtn);
  container.appendChild(wrapper);
}

function getEffectsArray() {
  var inputs = container.querySelectorAll('input[type="text"]');
  return Array.from(inputs)
    .map(function(input) { return input.value.trim(); })
    .filter(function(val) { return val !== ''; });
}
```

**Why This Matters:** This pattern will be reused in every data editor that has array or list fields. Consider extracting into a reusable component.

---

## Consolidated Form Fields Reduce Cognitive Load

**Context:** Originally had separate fields for "Associated Civ", "Civ with Specific Unlock", and "Civ Production Bonus" — but they all referred to the same civilization.

**Lesson:** When multiple form fields represent the same underlying entity, consolidate them into a single field. This:

- Reduces form complexity
- Prevents data inconsistency
- Makes the relationship clearer to users
- Simplifies validation logic

**Implementation:** Used one "Associated Civilization" autocomplete field, then referenced its ID in multiple database columns:

```javascript
var selectedAssociatedCivId = associatedCivField.getAttribute('data-selected-id');

var formData = {
  associatedCiv: selectedAssociatedCivId,
  civProductionBonus: selectedAssociatedCivId,
  civSpecificUnlock: {
    civId: selectedAssociatedCivId,
    civicId: selectedCivicId
  }
};
```

**Why This Matters:** This principle applies to all data editors — look for opportunities to simplify the user's mental model by consolidating related fields.

---

## Development Workflow: Stream Deck Integration

**Context:** Constantly needed to close old server, restart, and open browser tab manually.

**Lesson:** Small automation wins compound over time. Creating a single-button launcher that:

1. Kills existing server process on port 8080
2. Starts new http-server in background
3. Opens Chrome to the local page

...saved 30+ seconds and 5+ clicks per test iteration. Over a 30-commit day, that's 15+ minutes and significant context-switching reduction.

**Why This Matters:** Look for repetitive manual workflows and automate them early. Physical buttons (Stream Deck) are even better than keyboard shortcuts for frequently-used actions.

